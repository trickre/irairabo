<!DOCTYPE html>
<html>
	<header>
    <meta charset="utf-8">
<style type="text/css">
#svg {
  background-color: #c0ffee;

}
#LockButton {
  background-color: #ffee00;
  width: 20px;
  height:20px;
  position: absolute;
  left: 100px;
  top: 250px;
}
.rot2 { animation: rotation2 linear 3s infinite; }
@keyframes rotation2{
  from{transform-origin:188.8675px 80px; transform: rotate(0);}
  to  {transform-origin:188.8675px 80px; transform: rotate(-360deg);}
}
.clockwise { --rotto:360deg; }
.anticlockwise { --rotto:-360deg; }
.rot { animation: varrot linear 3s infinite; }
@keyframes varrot{
  from{transform-origin:var(--cx) var(--cy); transform: rotate(0);}
  to  {transform-origin:var(--cx) var(--cy); transform: rotate(var(--rotto));}
}
.vPiston { animation: varVPiston linear 1s infinite; }
@keyframes varVPiston{
    0%{transform: translateY(0);}
   50%{transform: translateY(var(--h));}
  100%{transform: translateY(0);}
}
.button {
  background-color: orange;
  border: gray;
  width: 50px;
  height: 40px;
}
</style>
</header>
	<body>
		<h1></h1>
		<div>
			<svg>
			</svg>
			<svg id="svg" width="1290" height="160">
<radialGradient id="sphere" fx="70%" fy="20%">
  <stop offset="0%" stop-color="#fff" />
  <stop offset="50%" stop-color="#fb0" />
  <stop offset="90%" stop-color="#c90" />
  <stop offset="100%" stop-color="#a80" />
</radialGradient>

			</svg>
		</div>
                <h2 id="timer">--:--.--</h2>
                <div class="button" onclick="StartTimer('inf')">start</div>
                <div id="debug"></div>

	</body>
	<script>
const NS = "http://www.w3.org/2000/svg";
const svg = document.getElementById('svg');
const debugwrite = document.getElementById('debug');
// 自機（カーソル）
let cursor_x = 30;
let cursor_y = 50;
const cursor_r = 10;
const cursor = (function () {
  const cursor = document.createElementNS(NS, 'circle');
  cursor.setAttribute('cx', cursor_x);
  cursor.setAttribute('cy', cursor_y);
  cursor.setAttribute('r', cursor_r);
  cursor.setAttribute('fill', "url(#sphere)");
  cursor.setAttribute('id', 'cursor');
  svg.appendChild(cursor);
  return cursor
})();

function move(dx, dy) {
  const old_x = cursor_x;
  const old_y = cursor_y;
  cursor_x += dx;
  cursor_y += dy;
  cursor.setAttribute('cx', cursor_x);
  cursor.setAttribute('cy', cursor_y);
};
svg.appendChild(cursor);


const DEG1 = Math.PI / 180;

/**
  直線状の壁を生成する。
   (x1, x2) : 始点
   (x2, y2) : 終点
   // 以下オプショナル引数
   (cx, cy) : 回転する時の中心
   a: 回転速度（deg/tick)
**/
function createLine(x1,y1, x2,y2) {
  return {
    type:"L", x1: x1, y1: y1, x2: x2, y2: y2,
    setRotation: function(cx, cy, a, init=0) {
      this.rot = { cx: cx, cy: cy, x1: x1, y1: y1, x2: x2, y2: y2, a: a, i: init };
      return this;
    },
    setCrank: function(dx, dy, a) {
      this.crk = { x1: x1, y1: y1, x2: x2, y2: y2, rx: dx/2, ry: dy/2, a: a, i: 0};
      return this;
    },
  };
}

/**
  円弧状の壁を生成する。
   (x0, y0) : 円弧の中心座標（みえない）
   r : 円弧の半径
   ap : 円弧の始点の、中心座標から見た時の極座標
   aq : 円弧の終点の、中心座標から見た時の極座標
   // 以下オプショナル引数
   (cx, cy) : 回転の中心
   a : 回転速度(deg/tick)
**/
function createArc(x0, y0, r, ap, aq, cx=0, cy=0, a=0, init=0) {
  //console.log("(",x0, y0, r, ap, aq,")");
  const x1 = x0 + r * Math.cos(ap*DEG1);
  const y1 = y0 + r * Math.sin(ap*DEG1);
  const x2 = x0 + r * Math.cos(aq*DEG1);
  const y2 = y0 + r * Math.sin(aq*DEG1);
  return {
    type: "A", x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0: y0, r: r,
    setRotation: function(cx, cy, a, init=0) {
      this.rot = {
               x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0, y0,
               cx: cx, cy: cy, a: a, i: init};
      return this;
    },
    setCrank: function() {
      this.crk = {};
      return this;
    },
  };
}

// 障害物
const walls = [
  //          x1, y1, x2, y2                   cx, cy, a
  createLine( 60, 30, 60,130).setRotation(88.8675, 80, 1),
  createLine( 60,130,147, 80).setRotation(88.8675, 80, 1),
  createLine(147, 80, 60, 30).setRotation(88.8675, 80, 1),
  {type: "z"},
  //         x0, y0,   r,  ap,     aq,       cx, cy,  a
  createArc(247, 80, 100, 150, 150+60).setRotation(188.8675, 80, -1),
  createArc(160,130, 100, 270, 270+60).setRotation(188.8675, 80, -1),
  createArc(160, 30, 100,  30,  30+60).setRotation(188.8675, 80, -1),
  {type: "z"},

  createLine( 380,  10, 420,  10).setRotation(400, 80, 1.2),
  createLine( 420,  10, 420, 150).setRotation(400, 80, 1.2),
  createLine( 420, 150, 380, 150).setRotation(400, 80, 1.2),
  createLine( 380, 150, 380,  10).setRotation(400, 80, 1.2),
  {type: "z"},

  createLine( 500, -10, 500,  20),
  createLine( 500,  20, 570,  20),
  createLine( 570,  20, 570, 130),
  createLine( 570, 130, 600, 130),
  createLine( 600, 130, 600, -10),
  {type: "z"},
  createLine( 500, 180, 500,  60),
  createLine( 500,  60, 540,  60),
  createLine( 540,  60, 540, 180),
  {type: "z"},
  createLine( 620, 180, 620,  25),
  createLine( 620,  25, 660,  25),
  createLine( 660,  25, 660, 180),
  {type: "z"},
  createLine( 680, -20, 680, 125),
  createLine( 680, 125, 700, 125),
  createLine( 700, 125, 700, -10),
  {type: "z"},
  // ここに上下運動のプレス機を実装
  createLine( 740, -45, 740,  10).setCrank(0, 40, 3),
  createLine( 740,  10, 780,  10).setCrank(0, 40, 3),
  createLine( 780,  10, 780, -45).setCrank(0, 40, 3),
  {type: "z"},
  createLine( 740, 170, 740,  70),
  createLine( 740,  70, 780,  70),
  createLine( 780,  70, 780, 170),
  {type: "z"},
  createLine( 820, -10, 820,  80.41889),
  createLine( 820, 80.41889, 840.9115348, 80.41889),
  //M840.9115348192676 80.41889066001582 A60 60 0 0 1 938.5672565811924 24.037333412861315 z
  // コツ：先に円弧だけ作成して、F12でDOMから実際の座標↑を取り出すのが手計算いらずで楽。
  createArc( 900, 70, 60, 170, 310),// x0, y0, r, ap, aq
  createLine( 938.56726, 24.03733, 980, 24.03733),
  createLine( 980, 24.03733, 980, -10),
  {type: "z"},
  //           x1,  y1,  x2,  y2,  cx,  cy,   a
  createLine( 900-50, 70- 5, 900+50, 70- 5).setRotation(900,  70, -0.4),
  createLine( 900+50, 70- 5, 900+50, 70+ 5).setRotation(900,  70, -0.4),
  createLine( 900+50, 70+ 5, 900-50, 70+ 5).setRotation(900,  70, -0.4),
  createLine( 900-50, 70+ 5, 900-50, 70- 5).setRotation(900,  70, -0.4),
  {type: "z"},
  createLine( 900- 5, 70-50, 900+ 5, 70-50).setRotation(900,  70, -0.4),
  createLine( 900+ 5, 70-50, 900+ 5, 70+50).setRotation(900,  70, -0.4),
  createLine( 900+ 5, 70+50, 900- 5, 70+50).setRotation(900,  70, -0.4),
  createLine( 900- 5, 70+50, 900- 5, 70-50).setRotation(900,  70, -0.4),
  {type: "z"},
  createLine( 980, 170, 980, 40),
  createLine( 980,  40, 951.96152, 40),
  //M951.9615242270663 40 A60 60 0 0 1 854.0373334128614 108.56725658119237 z
  createArc(900, 70, 60, -30, 140),
  createLine(854.03733, 108.55626, 820, 108.55626),
  createLine(820, 108.55626, 820, 180),
  {type: "z"},

];

// SVG生成
function resetSVG() {
  // カーソル以外を削除する
  // ※冒頭がカーソルであることを前提にしている
  /* https://freefielder.jp/blog/2015/09/javascript-remove-childnodes.html */
  while(svg.childElementCount>=3) {
    svg.removeChild(svg.lastChild);
  }
  let d = "M";
  let last = {x:0, y:0};
  for(let i=0;i<walls.length;i++) {
    const w = walls[i];
    if(w.type=="L") {
      if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
      d = d + "L" + w.x2 + " " + w.y2 + " ";
    }
    if(w.type=="A") {
      if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
      d = d + "A" + w.r + " " + w.r + " 0 0 1 " + w.x2 + " " + w.y2 + " ";
    }
    // pathを閉じる
    if(w.type=="z") {
      d = d + "z";
      const path = document.createElementNS(NS, 'path');
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('fill', 'none');
      svg.appendChild(path);
      d = "M";
    }
  }
  //test用もしくは模様
  //const c = document.createElementNS(NS, 'circle');
  //c.setAttribute('cx', 247);
  //c.setAttribute('cy', 80);
  //c.setAttribute('r', 99);
  //c.setAttribute('stroke', "#FF9900");
  //c.setAttribute('fill', "none");
  //svg.appendChild(c);
}

resetSVG();

// 入力判定
document.body.addEventListener('keydown',event=>{
  if(event.key==='d') { move(+10, 0); }
  if(event.key==='a') { move(-10, 0); }
  if(event.key==='w') { move(0, -10); }
  if(event.key==='s') { move(0, +10); }
});

// 当たり判定
function collision() {
  debugwrite.textContent = "";
  return walls.map(w=>{

    if(w.type=="L") {
      // https://yttm-work.jp/collision/collision_0006.html
      // 高校数学かなり忘れてて悲しくなった。
      const wx = w.x2 - w.x1;
      const wy = w.y2 - w.y1;
      const ux = cursor_x - w.x1;
      const uy = cursor_y - w.y1;
      const vx = cursor_x - w.x2;
      const vy = cursor_y - w.y2;
      const det = wx * uy - wy * ux;
      const len = Math.sqrt( wx*wx + wy*wy );
      const dst =  Math.abs(det) / len;
      if(dst > cursor_r) {
        return false; // 直線と中心の法線距離が十分遠ければ、触れていない
      }
      const dot1 = wx * ux + wy * uy;
      const dot2 = wx * vx + wy * vy;
      if(dot1*dot2 < 0) {
        // 壁ベクトルと、両端から中心までのベクトルとの、２つの内積の符号が異なる
        // ＝線分と円は触れている
        return true;
      }
      const v = Math.sqrt( vx*vx + vy*vy );
      // あとは、線分の終点が円内にあるかないかで決定する
      return (v <= cursor_r);
    }
    if(w.type=="A") {
      const dx = cursor_x - w.x0;
      const dy = cursor_y - w.y0;
      // 円弧の中心からの距離
      const d = Math.sqrt( dx*dx + dy*dy );
      if( Math.abs(w.r - cursor_r) < d && d < w.r + cursor_r ){
        // 全円には接している。

        const a1 = Math.atan2((w.y1    -w.y0),(w.x1    -w.x0));
        let   ac = Math.atan2((cursor_y-w.y0),(cursor_x-w.x0));
        let   a2 = Math.atan2((w.y2    -w.y0),(w.x2    -w.x0));
        while(ac<a1) { ac += 2 * Math.PI; }
        while(a2<a1) { a2 += 2 * Math.PI; }
        return ( a1 < ac && ac < a2 );
        return true;
      }
      return false;

    }

    // なんでもない＝衝突してない
    return false;

  }).reduce((a,b)=>a||b);
}
	</script>
        <script> const timerField = document.getElementById('timer'); const StartTimer = (function(){ let timerID = -1;
  return function(ms) {
    if(timerID!=-1) {
      clearInterval(timerID);
      timerID = -1;
    }
    if(timerField.textContent.indexOf('0')>=0){
      return false; // 二重起動防止（仮）
    }
    const limit = ms;
    const start = Date.now();
    timerID = setInterval(
      limit=="inf" ?
      function(){
        rotations();
        cranks();
        resetSVG();
        if(collision()){
          cursor.setAttribute('fill', 'red');
          Effect('explode1');
          clearInterval(timerID);// タイマー終了
        }else{
          cursor.setAttribute('fill', 'yellow');
        }
      } :
      function(){
        //{{{#section: 時限性の時の処理
        const now = Date.now();
        let rest= Math.max(0, limit - (now - start));
        const min = Math.floor(rest/60000);
        const sec = Math.floor((rest%60000)/1000);
        const mls = Math.floor((rest%1000)/10);
        timerField.textContent = 
          ('00'+min).slice(-2) + ':' +
          ('00'+sec).slice(-2) + '.' +
          ('00'+mls).slice(-2);
        if(rest == 0) {
          alert('Time Up!');
          clearInterval(timerID);// タイマー終了
          timerField.textContent = "--:--.--";
          return;
        }
        //}}}#section
        // 共通処理
    }, 10);
    return true;
  };
})();

// 回転アニメーションのコマ処理
function rotations() {
  walls.filter(w=>w.rot!=undefined).forEach(function(w){
    w.rot.i++;
    const th = w.rot.a * w.rot.i * Math.PI / 180;
    if(w.type=="L") {
      w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
    }
    if(w.type=="A") {
      w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x0 = (w.rot.x0-w.rot.cx) * Math.cos(th) - (w.rot.y0-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y0 = (w.rot.x0-w.rot.cx) * Math.sin(th) + (w.rot.y0-w.rot.cy) * Math.cos(th) + w.rot.cy;
    }
  });
}
function cranks() {
  walls.filter(w=>w.crk!=undefined).forEach(function(w){
    w.crk.i++;
    const th = w.crk.a * w.crk.i * Math.PI / 180;
    if(w.type=="L") {
      w.x1 = w.crk.x1 + w.crk.rx - w.crk.rx * Math.cos(th);
      w.x2 = w.crk.x2 + w.crk.rx - w.crk.rx * Math.cos(th);
      w.y1 = w.crk.y1 + w.crk.ry - w.crk.ry * Math.cos(th);
      w.y2 = w.crk.y2 + w.crk.ry - w.crk.ry * Math.cos(th);
    }

  });
}
//
function Effect(variation){
  if(variation=='explode1'){
    const s = 20; //debris' max size
    const debris = [...Array(100)].map(_=>{
      let M = "M " + cursor_x + " " + cursor_y;
      const l = " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
              + " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
              + " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
              + " z";
      const debri = document.createElementNS(NS, 'path');
      debri.setAttribute('d', M + l);
      debri.setAttribute('fill','Yellow');
      debri.setAttribute('stroke','Black');
      svg.appendChild(debri);
      return {
        l: l,
        body: debri,
        vx: Math.random()*60-30, vy: Math.random()*60-30,
        x: cursor_x, y: cursor_y,
      };
    });
    setInterval(function(){
      debris.forEach(function(d){
        d.vy+=.1;
        d.x+=d.vx;
        d.y+=d.vy;
        d.body.setAttribute('d', "M" + d.x + " " + d.y + d.l);
      });
    }, 10);
  }
}
        </script>
        <script>
function pointerLock(elem){
  const list = [
    "requestPointerLock",
    "webkitRequestPointerLock",
    "mozRequestPointerLock"
  ];

  for(const key in list) {
    if( elem[ list[key] ] ) {
      elem[ list[key] ]();
      return true;
    }
  }
  return false;
}

window.onload = () =>{
  const btn = document.getElementById('LockButton');
  btn.onclick = ()=>{
    pointerLock(btn);
    btn.hidden = true;
  };
};
        </script>
</html>
