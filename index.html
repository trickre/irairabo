<!DOCTYPE html>
<html>
<header>
  <meta charset="utf-8">
  <style type="text/css">
    #svg {
      background-color: #c0ffee;

    }

    #LockButton {
      background-color: #ffee00;
      width: 20px;
      height: 20px;
      position: absolute;
      left: 100px;
      top: 250px;
    }

    .rot2 {
      animation: rotation2 linear 3s infinite;
    }

    @keyframes rotation2 {
      from {
        transform-origin: 188.8675px 80px;
        transform: rotate(0);
      }

      to {
        transform-origin: 188.8675px 80px;
        transform: rotate(-360deg);
      }
    }

    .clockwise {
      --rotto: 360deg;
    }

    .anticlockwise {
      --rotto: -360deg;
    }

    .rot {
      animation: varrot linear 3s infinite;
    }

    @keyframes varrot {
      from {
        transform-origin: var(--cx) var(--cy);
        transform: rotate(0);
      }

      to {
        transform-origin: var(--cx) var(--cy);
        transform: rotate(var(--rotto));
      }
    }

    .vPiston {
      animation: varVPiston linear 1s infinite;
    }

    @keyframes varVPiston {
      0% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(var(--h));
      }

      100% {
        transform: translateY(0);
      }
    }

    #debug_g {
      float: left;
      margin-top: 400px;
    }

    .button {
      background-color: orange;
      border: gray;
      width: 50px;
      height: 40px;
    }
  </style>
</header>

<body>
  <h1></h1>
  <div>
    <svg>
    </svg>
    <svg id="svg" width="1290" height="160">
      <radialGradient id="sphere" fx="70%" fy="20%">
        <stop offset="0%" stop-color="#fff" />
        <stop offset="50%" stop-color="#fb0" />
        <stop offset="90%" stop-color="#c90" />
        <stop offset="100%" stop-color="#a80" />
      </radialGradient>
    </svg>
  </div>
  <h2>
    <span id="timer">--:--.--</span>
    <span onclick="StartTimer(10000);">/10sec(sample)</span>
  </h2>
  <div id="LockButton"></div>
  <div id="debug_g">
    <div>
      <h1 id="absolute"></h1>
    </div>
    <div>
      <h1 id="alpha"></h1>
    </div>
    <div>
      <h1 id="beta"></h1>
    </div>
    <div>
      <h1 id="gamma"></h1>
    </div>
  </div>
  <h2 id="timer">--:--.--</h2>
  <div class="button" onclick="StartTimer('inf')">start</div>
  <div id="debug"></div>

</body>
<script>
  /*****************************/
  /* G-sensor 利用のための準備 */
  /*****************************/
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    // iOS 13+
    //popupOpen("requestPermissionPopup");
    DeviceOrientationEvent.requestPermission().then(response => {
      if (response === 'granted') {
        window.addEventListener("deviceorientation", handleOrientation, true);
      }
    }).catch(console.error);
  } else {
    // non iOS 13+
    window.addEventListener("deviceorientation", handleOrientation, true);
  }
  
  if(DeviceMotionEvent.requestPermission){
    DeviceMotionEvent.requestPermission()
    .then(permissionStatus => {
      if(permissionStatus === 'granted'){
        window.addEventListener('devicemotion', (e)=>{
          if(!e.accelerationIncludingGravity){
            alert('No accelerationIncludingGravity');
            return;
          }
          alert(e.accelerationIncludingGravity.x);
        });
      }
    })
    .catch(console.error);
  }else{
    alert('No requestPermission');
  }

  const absolute = document.getElementById('absolute');
  const alpha = document.getElementById('alpha');
  const beta = document.getElementById('beta');
  const gamma = document.getElementById('gamma');

  /* 球の移動速度 */
  var v_x = 0.0;
  var v_y = 0.0;

  /* G変化時のイベント関数 */
  function handleOrientation(event) {
    absolute.textContent = FormatReal(event.absolute,3,4);
    alpha.textContent = FormatReal(event.alpha,3,4);
    beta.textContent = FormatReal(event.beta,3,4);
    gamma.textContent = FormatReal(event.gamma,3,4);
    
    v_x = v_x + event.gamma * 0.02;
    v_y = v_y + event.beta * 0.02;
    move(v_x,v_y);
  }

  function FormatReal(real, k1, k2){
    let int = Math.floor(real);
    let frc = real -int;
    int = ('='.repeat(k1)+int).slice(k1);
    frc = Math.floor(frc*Math.pow(10, k2)) % Math.pow(10, k2);
    return int + '.' + frc;
  }

  const NS = "http://www.w3.org/2000/svg";
  const svg = document.getElementById('svg');
  const debugwrite = document.getElementById('debug');
  // 自機（カーソル）
  let cursor_x = 30;
  let cursor_y = 50;
  const cursor_r = 10;
  //カーソルの生成とsvgへの配置
  const cursor = (function () {
    const cursor = document.createElementNS(NS, 'circle');
    cursor.setAttribute('cx', cursor_x);
    cursor.setAttribute('cy', cursor_y);
    cursor.setAttribute('r', cursor_r);
    cursor.setAttribute('fill', "url(#sphere)");
    cursor.setAttribute('id', 'cursor');
    svg.appendChild(cursor);
    return cursor
  })();

  function move(dx, dy) {
    const old_x = cursor_x;
    const old_y = cursor_y;
    cursor_x += dx;
    cursor_y += dy;
    cursor.setAttribute('cx', cursor_x);
    cursor.setAttribute('cy', cursor_y);
  };
  
  // 弧度法(rad法)に変換するための定数
  const DEG1 = Math.PI / 180;
  
  /**
    直線状の壁を生成する。
     (x1, x2) : 始点
     (x2, y2) : 終点
     // 以下オプショナル引数
     (cx, cy) : 回転する時の中心
     a: 回転速度（deg/tick)
  **/
  function createLine(x1,y1, x2,y2) {
    return {
      type:"L", x1: x1, y1: y1, x2: x2, y2: y2,
      setRotation: function(cx, cy, a, init=0) {
        this.rot = { cx: cx, cy: cy, x1: x1, y1: y1, x2: x2, y2: y2, a: a, i: init };
        return this;
      },
      setCrank: function(dx, dy, a) {
        this.crk = { x1: x1, y1: y1, x2: x2, y2: y2, rx: dx/2, ry: dy/2, a: a, i: 0};
        return this;
      },
    };
  }
  
  /**
    円弧状の壁を生成する。
     (x0, y0) : 円弧の中心座標（みえない）
     r : 円弧の半径
     ap : 円弧の始点の、中心座標から見た時の極座標
     aq : 円弧の終点の、中心座標から見た時の極座標
     // 以下オプショナル引数
     (cx, cy) : 回転の中心
     a : 回転速度(deg/tick)
  **/
  function createArc(x0, y0, r, ap, aq, cx=0, cy=0, a=0, init=0) {
    //console.log("(",x0, y0, r, ap, aq,")");
    const x1 = x0 + r * Math.cos(ap*DEG1);
    const y1 = y0 + r * Math.sin(ap*DEG1);
    const x2 = x0 + r * Math.cos(aq*DEG1);
    const y2 = y0 + r * Math.sin(aq*DEG1);
    return {
      type: "A", x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0: y0, r: r,
      setRotation: function(cx, cy, a, init=0) {
        this.rot = {
                 x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0, y0,
                 cx: cx, cy: cy, a: a, i: init};
        return this;
      },
      setCrank: function() {
        this.crk = {};
        return this;
      },
    };
  }
  
  // 障害物
  const walls = [
    //          x1, y1, x2, y2                   cx, cy, a
    createLine( 60, 30, 60,130).setRotation(88.8675, 80, 1),
    createLine( 60,130,147, 80).setRotation(88.8675, 80, 1),
    createLine(147, 80, 60, 30).setRotation(88.8675, 80, 1),
    {type: "z"},
    //         x0, y0,   r,  ap,     aq,       cx, cy,  a
    createArc(247, 80, 100, 150, 150+60).setRotation(188.8675, 80, -1),
    createArc(160,130, 100, 270, 270+60).setRotation(188.8675, 80, -1),
    createArc(160, 30, 100,  30,  30+60).setRotation(188.8675, 80, -1),
    {type: "z"},
  
    createLine( 380,  10, 420,  10).setRotation(400, 80, 1.2),
    createLine( 420,  10, 420, 150).setRotation(400, 80, 1.2),
    createLine( 420, 150, 380, 150).setRotation(400, 80, 1.2),
    createLine( 380, 150, 380,  10).setRotation(400, 80, 1.2),
    {type: "z"},
  
    createLine( 500, -10, 500,  20),
    createLine( 500,  20, 570,  20),
    createLine( 570,  20, 570, 130),
    createLine( 570, 130, 600, 130),
    createLine( 600, 130, 600, -10),
    {type: "z"},
    createLine( 500, 180, 500,  60),
    createLine( 500,  60, 540,  60),
    createLine( 540,  60, 540, 180),
    {type: "z"},
    createLine( 620, 180, 620,  25),
    createLine( 620,  25, 660,  25),
    createLine( 660,  25, 660, 180),
    {type: "z"},
    createLine( 680, -20, 680, 125),
    createLine( 680, 125, 700, 125),
    createLine( 700, 125, 700, -10),
    {type: "z"},
    // ここに上下運動のプレス機を実装
    createLine( 740, -45, 740,  10).setCrank(0, 40, 3),
    createLine( 740,  10, 780,  10).setCrank(0, 40, 3),
    createLine( 780,  10, 780, -45).setCrank(0, 40, 3),
    {type: "z"},
    createLine( 740, 170, 740,  70),
    createLine( 740,  70, 780,  70),
    createLine( 780,  70, 780, 170),
    {type: "z"},
    createLine( 820, -10, 820,  80.41889),
    createLine( 820, 80.41889, 840.9115348, 80.41889),
    //M840.9115348192676 80.41889066001582 A60 60 0 0 1 938.5672565811924 24.037333412861315 z
    // コツ：先に円弧だけ作成して、F12でDOMから実際の座標↑を取り出すのが手計算いらずで楽。
    createArc( 900, 70, 60, 170, 310),// x0, y0, r, ap, aq
    createLine( 938.56726, 24.03733, 980, 24.03733),
    createLine( 980, 24.03733, 980, -10),
    {type: "z"},
    //           x1,  y1,  x2,  y2,  cx,  cy,   a
    createLine( 900-50, 70- 5, 900+50, 70- 5).setRotation(900,  70, -0.4),
    createLine( 900+50, 70- 5, 900+50, 70+ 5).setRotation(900,  70, -0.4),
    createLine( 900+50, 70+ 5, 900-50, 70+ 5).setRotation(900,  70, -0.4),
    createLine( 900-50, 70+ 5, 900-50, 70- 5).setRotation(900,  70, -0.4),
    {type: "z"},
    createLine( 900- 5, 70-50, 900+ 5, 70-50).setRotation(900,  70, -0.4),
    createLine( 900+ 5, 70-50, 900+ 5, 70+50).setRotation(900,  70, -0.4),
    createLine( 900+ 5, 70+50, 900- 5, 70+50).setRotation(900,  70, -0.4),
    createLine( 900- 5, 70+50, 900- 5, 70-50).setRotation(900,  70, -0.4),
    {type: "z"},
    createLine( 980, 170, 980, 40),
    createLine( 980,  40, 951.96152, 40),
    //M951.9615242270663 40 A60 60 0 0 1 854.0373334128614 108.56725658119237 z
    createArc(900, 70, 60, -30, 140),
    createLine(854.03733, 108.55626, 820, 108.55626),
    createLine(820, 108.55626, 820, 180),
    {type: "z"},
  
  ];
  
  // SVG生成
  function resetSVG() {
    // カーソル以外を削除する
    // ※冒頭がカーソルであることを前提にしている
    /* https://freefielder.jp/blog/2015/09/javascript-remove-childnodes.html */
    while(svg.childElementCount>=3) {
      svg.removeChild(svg.lastChild);
    }
    let d = "M";
    let last = {x:0, y:0};
    for(let i=0;i<walls.length;i++) {
      const w = walls[i];
      if(w.type=="L") {
        if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
        d = d + "L" + w.x2 + " " + w.y2 + " ";
      }
      if(w.type=="A") {
        if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
        d = d + "A" + w.r + " " + w.r + " 0 0 1 " + w.x2 + " " + w.y2 + " ";
      }
      // pathを閉じる
      if(w.type=="z") {
        d = d + "z";
        const path = document.createElementNS(NS, 'path');
        path.setAttribute('d', d);
        path.setAttribute('stroke', 'black');
        path.setAttribute('fill', 'none');
        svg.appendChild(path);
        d = "M";
      }
    }
    //test用もしくは模様
    //const c = document.createElementNS(NS, 'circle');
    //c.setAttribute('cx', 247);
    //c.setAttribute('cy', 80);
    //c.setAttribute('r', 99);
    //c.setAttribute('stroke', "#FF9900");
    //c.setAttribute('fill', "none");
    //svg.appendChild(c);
  }
  
  // 入力判定
  document.body.addEventListener('keydown',event=>{
    if(event.key==='d') { move(+10, 0); }
    if(event.key==='a') { move(-10, 0); }
    if(event.key==='w') { move(0, -10); }
    if(event.key==='s') { move(0, +10); }
  });
  
  // 当たり判定
  function collision() {
    debugwrite.textContent = "";
    return walls.map(w=>{
  
      if(w.type=="L") {
        // https://yttm-work.jp/collision/collision_0006.html
        // 高校数学かなり忘れてて悲しくなった。
        const wx = w.x2 - w.x1;
        const wy = w.y2 - w.y1;
        const ux = cursor_x - w.x1;
        const uy = cursor_y - w.y1;
        const vx = cursor_x - w.x2;
        const vy = cursor_y - w.y2;
        const det = wx * uy - wy * ux;
        const len = Math.sqrt( wx*wx + wy*wy );
        const dst =  Math.abs(det) / len;
        if(dst > cursor_r) {
          return false; // 直線と中心の法線距離が十分遠ければ、触れていない
        }
        const dot1 = wx * ux + wy * uy;
        const dot2 = wx * vx + wy * vy;
        if(dot1*dot2 < 0) {
          // 壁ベクトルと、両端から中心までのベクトルとの、２つの内積の符号が異なる
          // ＝線分と円は触れている
          return true;
        }
        const v = Math.sqrt( vx*vx + vy*vy );
        // あとは、線分の終点が円内にあるかないかで決定する
        return (v <= cursor_r);
      }
      if(w.type=="A") {
        const dx = cursor_x - w.x0;
        const dy = cursor_y - w.y0;
        // 円弧の中心からの距離
        const d = Math.sqrt( dx*dx + dy*dy );
        if( Math.abs(w.r - cursor_r) < d && d < w.r + cursor_r ){
          // 全円には接している。
  
          const a1 = Math.atan2((w.y1    -w.y0),(w.x1    -w.x0));
          let   ac = Math.atan2((cursor_y-w.y0),(cursor_x-w.x0));
          let   a2 = Math.atan2((w.y2    -w.y0),(w.x2    -w.x0));
          while(ac<a1) { ac += 2 * Math.PI; }
          while(a2<a1) { a2 += 2 * Math.PI; }
          return ( a1 < ac && ac < a2 );
          return true;
        }
        return false;
  
      }
  
      // なんでもない＝衝突してない
      return false;
  
    }).reduce((a,b)=>a||b);
  }
  
  const timerField = document.getElementById('timer');
  const StartTimer = (function(){
    let timerID = -1;
    return function(ms) {
      if(timerID!=-1) {
        clearInterval(timerID);
        timerID = -1;
      }
      if(timerField.textContent.indexOf('0')>=0){
        return false; // 二重起動防止（仮）
      }
    const limit = ms;
    const start = Date.now();
  
    /********************/
    /* タイマー反復処理 */
    /********************/
    var timerID = setInterval(
        limit=="inf" ?
        function(){
          rotations();
          cranks();
          resetSVG();
          if(collision()){
            cursor.setAttribute('fill', 'red');
            Effect('explode1');
            clearInterval(timerID);// タイマー終了
          }else{
            cursor.setAttribute('fill', 'yellow');
          }
        } :
        function(){
          //{{{#section: 時限性の時の処理
          const now = Date.now();
          let rest= Math.max(0, limit - (now - start));
          const min = Math.floor(rest/60000);
          const sec = Math.floor((rest%60000)/1000);
          const mls = Math.floor((rest%1000)/10);
          timerField.textContent = 
            ('00'+min).slice(-2) + ':' +
            ('00'+sec).slice(-2) + '.' +
            ('00'+mls).slice(-2);
          if(rest == 0) {
            alert('Time Up!');
            clearInterval(timerID);// タイマー終了
            timerField.textContent = "--:--.--";
            return;
          }
          // 共通処理
        }, 10);
      return true;
    };
  })();
  
  // 回転アニメーションのコマ処理
  function rotations() {
    walls.filter(w=>w.rot!=undefined).forEach(function(w){
      w.rot.i++;
      const th = w.rot.a * w.rot.i * Math.PI / 180;
      if(w.type=="L") {
        w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
        w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
        w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
        w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
      }
      if(w.type=="A") {
        w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
        w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
        w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
        w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
        w.x0 = (w.rot.x0-w.rot.cx) * Math.cos(th) - (w.rot.y0-w.rot.cy) * Math.sin(th) + w.rot.cx;
        w.y0 = (w.rot.x0-w.rot.cx) * Math.sin(th) + (w.rot.y0-w.rot.cy) * Math.cos(th) + w.rot.cy;
      }
    });
  }
  function cranks() {
    walls.filter(w=>w.crk!=undefined).forEach(function(w){
      w.crk.i++;
      const th = w.crk.a * w.crk.i * Math.PI / 180;
      if(w.type=="L") {
        w.x1 = w.crk.x1 + w.crk.rx - w.crk.rx * Math.cos(th);
        w.x2 = w.crk.x2 + w.crk.rx - w.crk.rx * Math.cos(th);
        w.y1 = w.crk.y1 + w.crk.ry - w.crk.ry * Math.cos(th);
        w.y2 = w.crk.y2 + w.crk.ry - w.crk.ry * Math.cos(th);
      }
  
    });
  }
  //
  function Effect(variation){
    if(variation=='explode1'){
      const s = 20; //debris' max size
      const debris = [...Array(100)].map(_=>{
        let M = "M " + cursor_x + " " + cursor_y;
        const l = " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
                + " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
                + " l " + (Math.random()*s*2-s) + " " + (Math.random()*s*2-s)
                + " z";
        const debri = document.createElementNS(NS, 'path');
        debri.setAttribute('d', M + l);
        debri.setAttribute('fill','Yellow');
        debri.setAttribute('stroke','Black');
        svg.appendChild(debri);
        return {
          l: l,
          body: debri,
          vx: Math.random()*60-30, vy: Math.random()*60-30,
          x: cursor_x, y: cursor_y,
        };
      });
      setInterval(function(){
        debris.forEach(function(d){
          d.vy+=.1;
          d.x+=d.vx;
          d.y+=d.vy;
          d.body.setAttribute('d', "M" + d.x + " " + d.y + d.l);
        });
      }, 10);
    }
  }
  function pointerLock(elem){
    const list = [
      "requestPointerLock",
      "webkitRequestPointerLock",
      "mozRequestPointerLock"
    ];
  
    for(const key in list) {
      if( elem[ list[key] ] ) {
        elem[ list[key] ]();
        return true;
      }
    }
    return false;
  }
  
  window.onload = () =>{
    resetSVG();
  
    const btn = document.getElementById('LockButton');
    btn.onclick = ()=>{
      pointerLock(btn);
      btn.hidden = true;
    };
  };
</script>
</html>
