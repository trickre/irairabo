<html>
<header>
  <style type="text/css">
    #svg {
      background-color: #c0ffee;
    }

    .anime1 {
      animation: strokeAnimation1 linear 3s infinite;
    }

    @keyframes strokeAnimation1 {
      from {
        transform-origin: 185px 90px;
        transform: rotate(0);
      }

      to {
        transform-origin: 185px 90px;
        transform: rotate(360deg);
      }
    }
  </style>
</header>

<body>
  <h1>イライラゲーム棒</h1>
  <div>
    <svg id="svg" width="290" height="160">

    </svg>
  </div>
  <h2 id="timer">--:--.--</h2>

</body>
<script>
  const NS = "http://www.w3.org/2000/svg";
  const svg = document.getElementById('svg');
  // 自機（カーソル）
  let cursor_x = 30;
  let cursor_y = 50;
  const cursor_r = 10;
  const cursor = (function () {
    const cursor = document.createElementNS(NS, 'circle');
    cursor.setAttribute('cx', cursor_x);
    cursor.setAttribute('cy', cursor_y);
    cursor.setAttribute('r', cursor_r);
    cursor.setAttribute('fill', "#ED3");
    cursor.setAttribute('id', 'cursor');
    svg.appendChild(cursor);
    return cursor
  })();

  function move(dx, dy) {
    const old_x = cursor_x;
    const old_y = cursor_y;
    cursor_x += dx;
    cursor_y += dy;
    cursor.setAttribute('cx', cursor_x);
    cursor.setAttribute('cy', cursor_y);
  };

// 障害物
const walls = [
  {type:"L", x1: 60, y1: 30, x2: 60, y2:130, rot: {cx: 88.8675, cy:80, x1: 60, y1: 30, x2: 60, y2:130, a:0.01, i:0} },
  {type:"L", x1: 60, y1:130, x2:147, y2: 80, rot: {cx: 88.8675, cy:80, x1: 60, y1:130, x2:147, y2: 80, a:0.01, i:0} },
  {type:"L", x1:147, y1: 80, x2: 60, y2: 30, rot: {cx: 88.8675, cy:80, x1:147, y1: 80, x2: 60, y2: 30, a:0.01, i:0} },
  {type:"z"},
  {type:"L", x1:160, y1: 30, x2:160, y2:130, rot: {cx:188.8675, cy:80, x1:160, y1: 30, x2:160, y2:130, a:-0.01, i:0} },
  {type:"L", x1:160, y1:130, x2:247, y2: 80, rot: {cx:188.8675, cy:80, x1:160, y1:130, x2:247, y2: 80, a:-0.01, i:0} },
  {type:"L", x1:247, y1: 80, x2:160, y2: 30, rot: {cx:188.8675, cy:80, x1:247, y1: 80, x2:160, y2: 30, a:-0.01, i:0} },
  {type:"z"},
];
  // SVG生成
  function resetSVG() {
    // 冒頭がカーソルであることを前提にしている
    /* https://freefielder.jp/blog/2015/09/javascript-remove-childnodes.html */
    while (svg.childElementCount >= 2) {
      svg.removeChild(svg.lastChild);
    }
    let d = "M";
    let last = {
      x: 0,
      y: 0
    };
    for (let i = 0; i < walls.length; i++) {
      const w = walls[i];
      if (w.type == "L") {
        if (d == "M") d = d + w.x1 + " " + w.y1 + " ";
        d = d + "L" + w.x2 + " " + w.y2 + " ";
      }
      // pathを閉じる
      if (w.type == "z") {
        d = d + "z";
        const path = document.createElementNS(NS, 'path');
        path.setAttribute('d', d);
        path.setAttribute('stroke', 'black');
        path.setAttribute('fill', 'none');
        svg.appendChild(path);
        d = "M";
      }
    }
  }

  resetSVG();
  //const barrier = document.createElementNS(NS, 'path');
  //barrier.setAttribute('d', 'M200 20 L130 140 L280 140 L280 100 z');
  ////barrier.setAttribute('fill', '');
  //barrier.setAttribute('stroke', 'black');
  //svg.appendChild(barrier);
  //barrier.addEventListener('mouseover', event=>{
  //  event.target.setAttribute('fill','red');
  //});
  //barrier.addEventListener('mouseout', event=>{
  //  event.target.setAttribute('fill','black');
  //});
  //const rot1 = document.getElementById('rot1');
  //rot1.addEventListener('mouseover', event=>{
  //  event.target.setAttribute('fill','red');
  //});
  //rot1.addEventListener('mouseout', event=>{
  //  event.target.setAttribute('fill','black');
  //});

  // 入力判定
  document.body.addEventListener('keydown',event=>{
  if(event.key==='d') { move(+10, 0); }
  if(event.key==='a') { move(-10, 0); }
  if(event.key==='w') { move(0, -10); }
  if(event.key==='s') { move(0, +10); }
  });

  // 当たり判定
  function collision() {
  return walls.map(w=>{

  if(w.type=="L") {
  // https://yttm-work.jp/collision/collision_0006.html
  // 高校数学かなり忘れてて悲しくなった。
  const wx = w.x2 - w.x1;
  const wy = w.y2 - w.y1;
  const ux = cursor_x - w.x1;
  const uy = cursor_y - w.y1;
  const vx = cursor_x - w.x2;
  const vy = cursor_y - w.y2;
  const det = wx * uy - wy * ux;
  const len = Math.sqrt( wx*wx + wy*wy );
  const dst = Math.abs(det) / len;
  if(dst > cursor_r) {
  return false; // 直線と中心の法線距離が十分遠ければ、触れていない
  }
  const dot1 = wx * ux + wy * uy;
  const dot2 = wx * vx + wy * vy;
  if(dot1*dot2 < 0) {
        return true; // 壁ベクトルと、両端から中心までのベクトルとの、２つの内積の符号が異なる＝線分と円は触れている
      }
      const v = Math.sqrt( vx*vx + vy*vy );
      // あとは、線分の終点が円内にあるかないかで決定する
      return (v <= cursor_r);
    }

    // なんでもない＝衝突してない
    return false;

  }).reduce((a,b)=>a||b);
}
    
    const timerField = document.getElementById('timer');
    const StartTimer = function (ms) {
    if (timerField.textContent.indexOf('0') >= 0) {
    return false; // 二重起動防止（仮）
    }
    const limit = ms;
    const start = Date.now();
    const timerID = setInterval(
    limit == "inf" ?
    function () {
    rotations();
    resetSVG();
    if (collision()) {
    cursor.setAttribute('fill', 'red');
    } else {
    cursor.setAttribute('fill', 'yellow');
    }
    } :
    function () {
    //{{{#section: 次元性の時の処理
            const now = Date.now();
            let rest = Math.max(0, limit - (now - start));
            const min = Math.floor(rest / 60000);
            const sec = Math.floor((rest % 60000) / 1000);
            const mls = Math.floor((rest % 1000) / 10);
            timerField.textContent =
              ('00' + min).slice(-2) + ':' +
              ('00' + sec).slice(-2) + '.' +
              ('00' + mls).slice(-2);
            if (rest == 0) {
              alert('Time Up!');
              clearInterval(timerID);
              timerField.textContent = "--:--.--";
              return;
            }
            //}}}#section
    // 共通処理
    }, 10);
    return true;
    };

    // 回転アニメーションのコマ処理
    function rotations() {
    walls.filter(w => w.rot != undefined).forEach(function (w) {
    w.rot.i++;
    const th = w.rot.a * w.rot.i;
    w.x1 = (w.rot.x1 - w.rot.cx) * Math.cos(th) - (w.rot.y1 - w.rot.cy) * Math.sin(th) + w.rot.cx;
    w.y1 = (w.rot.x1 - w.rot.cx) * Math.sin(th) + (w.rot.y1 - w.rot.cy) * Math.cos(th) + w.rot.cy;
    w.x2 = (w.rot.x2 - w.rot.cx) * Math.cos(th) - (w.rot.y2 - w.rot.cy) * Math.sin(th) + w.rot.cx;
    w.y2 = (w.rot.x2 - w.rot.cx) * Math.sin(th) + (w.rot.y2 - w.rot.cy) * Math.cos(th) + w.rot.cy;
    });
    }
    </script>

    </html>
